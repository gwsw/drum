<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title> Drum Patterns </title>
</head>

<body onload="init()">

<table>
<tr><td style="width:100px"> Pattern: </td><td style="width:120px"> <input type="text" id="pattern" name="pattern" size="30"> </td>
    <td rowspan="3">
    <input type="button" id="play_btn" value="Play" onclick="click_play()"> <br/>
    <input type="button" id="save_btn" value="Save" onclick="click_save()"> <br/>
    <input type="button" id="load_btn" value="Load" onclick="click_load()"> <br/>
    </td>
</tr>
<tr><td> Pattern type: </td><td>
    <select id="ptype" onchange="change_ptype()">
      <option value="B">Beat notation</option>
      <option value="M">Music notation</option>
    </select> </td>
</tr>
<tr><td> BPM: </td>
    <td> <input type="number" id="bpm" value="90" onchange="change_bpm()"> </td>
</tr>
<tr><td></td><td><span id="prog" style="font-family:monospace; font-size:3vw"></span></td></tr>
</table>

<p>
<div id="beat_pat_help" style="color:green">
Pattern is space-separated list of '(drum)(beat)', where
<table>
  <tr><td>(drum)</td> <td> b=bass, s=snare, h=hi-hat; may be omitted to repeat the previous drum </td></tr>
  <tr><td>(beat)</td> <td> 1 1e 1& 1u 2 2e etc. or * to hit each empty note </td></tr>
</table>
</div>

<div id="music_pat_help" style="color:green; display:none">
Pattern is space-separated list of '(drum)(skip)', where (drum) is 
  <table>
  <tr><td>(drum)</td> <td> b=bass, s=snare, h=hi-hat, x=rest; may be omitted to repeat the previous drum </td></tr>
  <tr><td>(skip)</td> <td> 1=whole note, 2=half, 4=quarter, 8=eighth, 6=sixteenth</td></tr>
  </table>
</div>
</p>

<p id="msg" style="color:red"></p>

<script>
// -------------------------------------------------------------------

// Constants
var bass_bang      = null;
var snare_bang     = null;
var hihat_bang     = null;
var notes_per_bar  = 16;
var beats_per_bar  = 4;
var notes_per_beat = notes_per_bar / beats_per_bar;

// Globals
var g_bpm          = 90;
var g_graph        = null;
var g_music_bar    = null;
var g_note         = -1;
var g_start        = 0;

// -------------------------------------------------------------------
class AudioGraph {
    constructor() {
        this.audio = new (window.AudioContext || window.webkitAudioContext);
        this.gain = this.audio.createGain();
        this.set_gain(0);
        this.gain.connect(this.audio.destination);
        this.osc = this.audio.createOscillator();
        this.osc.connect(this.gain);
        this.osc.start(0);
    }
    play_tone(freq, dur, gain) {
        this.osc.frequency.value = freq;
        this.set_gain(gain);
        ///FIXME window.setTimeout(function() { this.set_gain(0); }, dur);
        window.setTimeout(AudioGraph_stop, dur);
    }
    set_gain(gain) {
        this.gain.gain.setValueAtTime(gain, this.audio.currentTime);
    }
};
function AudioGraph_stop() {
    g_graph.set_gain(0);
}

// -------------------------------------------------------------------
class MusicBar {
    constructor(pattern, ptype) {
        this.bangs = [];
        for (let n = 0; n < notes_per_bar; ++n) {
            this.bangs.push([]);
        }
        if (ptype == "B") {
            this.init_beat(pattern);
        } else if (ptype == "M") {
            this.init_music(pattern);
        } else {
            msg("Invalid pattern type '"+ptype+"'.");
        }
    }
    // b1 s2 b3 b3& s4
    init_beat(pattern) {
        let note = -1;
        let bang = null;
        pattern += ' ';
        for (const ch of pattern.split('')) {
            if (ch == '\r' || ch == '\n') {
                ;
            } else if (ch == ' ' || ch == ',') {
                if (note >= 0) {
                    if (bang != null) {
                        this.bangs[note].push(bang);
                    }
                    note = -1;
                }
            } else if (ch == '*') {
                this.add_all(bang);
            } else if (ch == 'b') {
                bang = bass_bang;
            } else if (ch == 's') {
                bang = snare_bang;
            } else if (ch == 'h') {
                bang = hihat_bang;
            } else if (ch == '1') {
                note = 0;
            } else if (ch == '2') {
                note = notes_per_beat;
            } else if (ch == '3') {
                note = 2*notes_per_beat;
            } else if (ch == '4') {
                note = 3*notes_per_beat;
            } else if (ch == '&') {
                note += notes_per_beat/2;
            } else if (ch == 'e') {
                note += notes_per_beat/4;
            } else if (ch == 'u') {
                note += 3*notes_per_beat/4;
            } else {
                msg("Invalid character '"+ch+"' in pattern.");
            }
            if (note >= this.bangs.length) {
                msg("Note "+note.toString()+" out of range.");
                note = this.bangs.length-1;
            }
        }
    }
    // b4 s8 x6 b6 x8 b6 b6 s4
    init_music(pattern) {
        let note = 0;
        let bang = null;
        let skip = -1;
        pattern += ' ';
        for (const ch of pattern.split('')) {
            if (ch == '\r' || ch == '\n') {
                ;
            } else if (ch == ' ' || ch == ',') {
                if (bang != null) {
                    if (note >= this.bangs.length) {
                        msg("Note "+note.toString()+" out of range.");
                        note = this.bangs.length-1;
                    }
                    this.bangs[note].push(bang);
                }
                if (skip >= 0) {
                    note += skip;
                    skip = -1;
                }
            } else if (ch == '*') {
                this.add_all(bang);
                bang = null;
            } else if (ch == 'b') {
                bang = bass_bang;
            } else if (ch == 's') {
                bang = snare_bang;
            } else if (ch == 'h') {
                bang = hihat_bang;
            } else if (ch == 'x') { // rest
                bang = null;
            } else if (ch == '1' || ch == 'w') {
                skip = notes_per_bar;
            } else if (ch == '2' || ch == 'h') {
                skip = round(notes_per_bar/2);
            } else if (ch == '4' || ch == 'q') {
                skip = round(notes_per_bar/4);
            } else if (ch == '8' || ch == 'e') {
                skip = round(notes_per_bar/8);
            } else if (ch == '6') {
                skip = round(notes_per_bar/16);
            } else if (ch == '3' || ch == 't') {
                skip = round(notes_per_bar/32);
            } else {
                msg("Invalid character '"+ch+"' in pattern.");
            }
        }
        if (note != notes_per_bar) {
            msg("Expected "+notes_per_bar.toString()+" notes/bar; got "+note.toString()+".");
        }
    }
    add_all(bang) {
        if (bang == null) return;
        for (let n = 0; n < this.bangs.length; ++n) {
            if (this.bangs[n].length == 0) {
                this.bangs[n].push(bang);
            }
        }
    }
    bang(idx) {
        return this.bangs[idx % this.bangs.length];
    }
    total_bangs() {
        let bangs = 0;
        for (const bang of this.bangs) {
            bangs += bang.length;
        }
        return bangs;
    }
}

// -------------------------------------------------------------------
class Bang {
    constructor(freq, dur, gain) {
        this.freq = freq;
        this.dur = dur;
        this.gain = gain;
    }
    play() {
        g_graph.play_tone(this.freq, this.dur, this.gain);
    }
}

// -------------------------------------------------------------------

function init() {
    g_graph = new AudioGraph();
    bass_bang  = new Bang(120, 100, 1);
    snare_bang = new Bang(240, 100, 1);
    hihat_bang = new Bang(600, 40, .1);
}

function click_play() {
    msg(null);
    let btn = el("play_btn");
    if (g_note < 0) { // start playing
        const pattern = el("pattern").value;
        const ptype = el("ptype").value;
        g_music_bar = new MusicBar(pattern, ptype);
        if (g_music_bar.total_bangs() == 0) {
            msg("Nothing to play.");
            return;
        }
        display_help(false, false);
        btn.value = "Stop";
        g_note = 0;
        g_start = now();
        next_bang();
    } else { // stop playing
        change_ptype();
        btn.value = "Play";
        el("prog").innerHTML = "";
        g_note = -1;
    }
}

function click_save() {
}

function click_load() {
}

function change_ptype() {
    el("pattern").value = "";
    const sel = el("ptype").selectedIndex;
    if (sel == 0) {
        display_help(true, false);
    } else {
        display_help(false, true);
    }
}

function display_help(beat, music) {
    el("beat_pat_help").style.display = beat ? "block" : "none";
    el("music_pat_help").style.display = music ? "block" : "none";
}

function change_bpm() {
    g_bpm = el("bpm").value;
}

function next_bang() {
    if (g_note < 0) return;
    for (const bang of g_music_bar.bang(g_note)) {
        bang.play();
    }
    const beat = Math.floor(g_note / notes_per_beat);
    let s = "";
    for (let b = 0; b < beats_per_bar; ++b) {
        s += (b <= (beat % beats_per_bar)) ? "@" : ".";
    }
    el("prog").innerHTML = s;
    ++g_note;

    const ms_per_note = (60*1000 * beats_per_bar) / (g_bpm * notes_per_bar);
    window.setTimeout(next_bang, ms_per_note);
}

function round(x) {
    return Math.floor(x + 0.5);
}

function msg(s, id) {
    if (id === undefined) id = "msg";
    if (s == null) {
        el(id).innerHTML = ""
    } else {
        el(id).innerHTML += s + "<br>";
    }
}

function now() {
    return performance.now();
}

function el(id) {
    return document.getElementById(id);
}

</script>
</body>
